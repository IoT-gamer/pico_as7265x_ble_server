/*
 * ble_server.c
 *
 * BLE server implementation for the Pico Spectral Sensor.
 * Uses a custom GATT profile to expose spectral data and control commands.
 *
 */

#include "ble_server.h"
#include <stdio.h>
#include <string.h>
#include "btstack.h"
#include "pico/stdlib.h"

// Include your sensor driver
#include "as7265x.h" 

// Include the generated GATT header
#include "spectral.h"

// --- Globals ---
static hci_con_handle_t server_con_handle = HCI_CON_HANDLE_INVALID;

// Reference to the sensor object defined in main.c
extern as7265x_t sensor; 

// --- Advertising Data ---
static uint8_t adv_data[] = {
    // Flags: General Discoverable
    0x02, BLUETOOTH_DATA_TYPE_FLAGS, 0x06,
    // Name: "Pico-Spectral"
    0x0E, BLUETOOTH_DATA_TYPE_COMPLETE_LOCAL_NAME, 
    'P', 'i', 'c', 'o', '-', 'S', 'p', 'e', 'c', 't', 'r', 'a', 'l',
    // 16-bit Service UUIDs (Custom Service 0xFF00)
    0x03, BLUETOOTH_DATA_TYPE_COMPLETE_LIST_OF_16_BIT_SERVICE_CLASS_UUIDS, 0x00, 0xFF
};
static const uint8_t adv_data_len = sizeof(adv_data);

// --- Forward Declarations ---
static uint16_t att_read_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t offset, uint8_t * buffer, uint16_t buffer_size);
static int att_write_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t transaction_mode, uint16_t offset, uint8_t *buffer, uint16_t buffer_size);

// --- Public API ---

void ble_server_init(btstack_packet_handler_t att_packet_handler) {
    // Initialize ATT server with the profile data (from spectral_gatt.h)
    att_server_init(profile_data, att_read_callback, att_write_callback);
    
    // Register the handler for ATT events
    att_server_register_packet_handler(att_packet_handler);
}

void ble_server_start_advertising(void) {
    printf("Starting BLE advertising...\n");
    // Advertise every ~500ms (800 * 0.625ms)
    uint16_t adv_int = 800; 
    uint8_t adv_type = 0;
    bd_addr_t null_addr;
    memset(null_addr, 0, 6);
    
    gap_advertisements_set_params(adv_int, adv_int, adv_type, 0, null_addr, 0x07, 0x00);
    gap_advertisements_set_data(adv_data_len, (uint8_t*) adv_data);
    gap_advertisements_enable(1);
}

void ble_server_stop_advertising(void) {
    gap_advertisements_enable(0);
}

hci_con_handle_t ble_server_get_con_handle(void) {
    return server_con_handle;
}

void ble_server_handle_hci_event(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) {
    if (packet_type != HCI_EVENT_PACKET) return;

    uint8_t event_type = hci_event_packet_get_type(packet);

    switch (event_type) {
        case HCI_EVENT_LE_META:
            if (hci_event_le_meta_get_subevent_code(packet) == HCI_SUBEVENT_LE_CONNECTION_COMPLETE) {
                server_con_handle = hci_subevent_le_connection_complete_get_connection_handle(packet);
                printf("BLE Client Connected.\n");
                ble_server_stop_advertising();
            }
            break;

        case HCI_EVENT_DISCONNECTION_COMPLETE:
            if (hci_event_disconnection_complete_get_connection_handle(packet) == server_con_handle) {
                server_con_handle = HCI_CON_HANDLE_INVALID;
                printf("BLE Client Disconnected.\n");
                ble_server_start_advertising();
            }
            break;

        // Use the event suggested by your compiler
        case ATT_EVENT_MTU_EXCHANGE_COMPLETE: 
            {
                uint16_t mtu = att_event_mtu_exchange_complete_get_MTU(packet);
                printf("MTU Exchange Complete: %u bytes\n", mtu);
            }
            break;
    }
}

/**
 * @brief Sends spectral data notification.
 * Formats: 3 characteristics, each with 6 floats (24 bytes).
 */
void ble_server_notify_spectral_data(float *channels) {
    if (server_con_handle == HCI_CON_HANDLE_INVALID) return;

    // The handles generated by btstack from spectral.gatt
    uint16_t handles[] = {
        ATT_CHARACTERISTIC_0000FF01_0000_1000_8000_00805F9B34FB_01_VALUE_HANDLE,
        ATT_CHARACTERISTIC_0000FF02_0000_1000_8000_00805F9B34FB_01_VALUE_HANDLE,
        ATT_CHARACTERISTIC_0000FF03_0000_1000_8000_00805F9B34FB_01_VALUE_HANDLE
    };

    for (int s = 0; s < 3; s++) {
        // Calculate the pointer to the start of this sensor's 6 floats
        // Main = channels[0], Secondary1 = channels[6], Secondary2 = channels[12]
        uint8_t *data_ptr = (uint8_t *)&channels[s * 6];
        uint16_t data_len = 6 * sizeof(float); // 24 bytes

        att_server_notify(server_con_handle, handles[s], data_ptr, data_len);
    }
    
    printf("BLE: Notified 18 channels via 3 characteristics.\n");
}


// --- Internal Callbacks ---

static uint16_t att_read_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t offset, uint8_t * buffer, uint16_t buffer_size) {
    return 0; // No readable characteristics defined in this profile
}

/**
 * @brief Handles writes from the phone app.
 * Protocol: [Command Byte] [Value Byte]
 */
static int att_write_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t transaction_mode, uint16_t offset, uint8_t *buffer, uint16_t buffer_size) {
    
    // Check if write is to our Control Characteristic (UUID ...FF04)
    if (att_handle == ATT_CHARACTERISTIC_0000FF04_0000_1000_8000_00805F9B34FB_01_VALUE_HANDLE) {
        
        if (buffer_size < 2) return 0; // Ignore malformed packets

        uint8_t cmd = buffer[0];
        uint8_t val = buffer[1];

        printf("BLE Write Cmd: 0x%02X Val: 0x%02X\n", cmd, val);

        switch(cmd) {
            case 0x01: // Set Gain
                // 0=1x, 1=3.7x, 2=16x, 3=64x
                as7265x_set_gain(&sensor, val);
                printf("Set Gain: %d\n", val);
                break;

            case 0x02: // Set Integration Time
                // val * 2.8ms
                as7265x_set_integration_time(&sensor, val);
                printf("Set Integ Time: %d\n", val);
                break;

            case 0x03: // Toggle NIR LED (Main)
                as7265x_set_led_drv_enable(&sensor, AS7265X_SEL_MASTER, val > 0); 
                break;

            case 0x04: // Toggle VIS LED (Secondary 1)
                as7265x_set_led_drv_enable(&sensor, AS7265X_SEL_SLAVE1, val > 0);
                printf("Set VIS LED: %d\n", val);
                break;

            case 0x05: // Toggle UV LED (Secondary 2)
                as7265x_set_led_drv_enable(&sensor, AS7265X_SEL_SLAVE2, val > 0);
                printf("Set UV LED: %d\n", val);
                break;
                
            default:
                printf("Unknown Command\n");
        }
    }
    return 0;
}